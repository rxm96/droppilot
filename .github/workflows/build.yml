name: build

on:
  push:
    branches: [main]
    tags: ["v*"]
  workflow_dispatch:

permissions:
  contents: write
  models: read

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [windows-latest, macos-latest]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install deps
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Build renderer/main
        run: npm run build

      - name: Package (Windows)
        if: runner.os == 'Windows'
        env:
          CSC_IDENTITY_AUTO_DISCOVERY: "false"
        run: npx electron-builder --win --publish never

      - name: Package (macOS)
        if: runner.os == 'macOS'
        env:
          CSC_IDENTITY_AUTO_DISCOVERY: "false"
        run: npx electron-builder --mac --publish never

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: droppilot-${{ runner.os }}
          path: |
            release/*.exe
            release/*.blockmap
            release/*.dmg
            release/*.zip
            release/*.yml

  release:
    runs-on: ubuntu-latest
    needs: build
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: true

      - name: Generate technical release notes
        id: generated_notes
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const tag = context.ref.replace("refs/tags/", "");
            const isPrereleaseTag = /-(test|rc|beta|alpha)(?:[.-]\d+)?$/i.test(tag);

            let previousTagName;
            if (isPrereleaseTag) {
              const releases = await github.paginate(github.rest.repos.listReleases, {
                owner,
                repo,
                per_page: 100,
              });
              const stable = releases.find((release) => !release.draft && !release.prerelease);
              if (stable?.tag_name) {
                previousTagName = stable.tag_name;
              }
            }

            const params = {
              owner,
              repo,
              tag_name: tag,
              target_commitish: context.sha,
              ...(previousTagName ? { previous_tag_name: previousTagName } : {}),
            };
            const { data } = await github.rest.repos.generateReleaseNotes(params);
            const body = (data.body ?? "").trim();
            const onlyFullChangelog =
              /^full\s+changelog\b[:\s-]*/i.test(body.replace(/^#+\s*/g, ""));
            core.setOutput("notes", onlyFullChangelog ? "" : body);
            core.setOutput("base_tag", previousTagName ?? "");
            core.setOutput("tag", tag);
            core.setOutput("is_prerelease", String(isPrereleaseTag));

      - name: Gather additional release context
        id: release_context
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const tag = context.ref.replace("refs/tags/", "");
            const base = `${{ steps.generated_notes.outputs.base_tag }}`.trim();

            if (!base) {
              core.setOutput("context", "No previous tag available for commit comparison.");
              return;
            }

            try {
              const { data } = await github.rest.repos.compareCommitsWithBasehead({
                owner,
                repo,
                basehead: `${base}...${tag}`,
                per_page: 100,
              });

              const commitSummaries = Array.from(
                new Set(
                  (data.commits ?? [])
                    .map((commit) => String(commit.commit?.message ?? "").split("\n")[0].trim())
                    .filter((line) => line.length > 0)
                    .filter((line) => !/^chore\(release\):\s*v/i.test(line)),
                ),
              ).slice(0, 20);

              const changedFiles = Array.from(
                new Set((data.files ?? []).map((file) => file.filename).filter(Boolean)),
              ).slice(0, 30);

              const inferArea = (file) => {
                if (/priority|target/i.test(file)) return "priority-targeting";
                if (/inventory/i.test(file)) return "inventory";
                if (/channel/i.test(file)) return "channels";
                if (/update|overlay/i.test(file)) return "updates";
                if (/auth|session/i.test(file)) return "auth-session";
                if (/settings|theme|i18n/i.test(file)) return "settings";
                if (/build\.yml|workflow|package\.json/i.test(file))
                  return "release-pipeline";
                return null;
              };
              const inferredAreas = Array.from(
                new Set(changedFiles.map((file) => inferArea(file)).filter(Boolean)),
              ).slice(0, 8);

              const commitSection = commitSummaries.length
                ? commitSummaries.map((line) => `- ${line}`).join("\n")
                : "- (no commit summaries found)";
              const filesSection = changedFiles.length
                ? changedFiles.map((line) => `- ${line}`).join("\n")
                : "- (no changed files listed)";
              const areaSection = inferredAreas.length
                ? inferredAreas.map((line) => `- ${line}`).join("\n")
                : "- (no feature areas inferred)";

              const contextBlock = [
                `Base tag: ${base}`,
                `Target tag: ${tag}`,
                "",
                "Commit summaries:",
                commitSection,
                "",
                "Changed files:",
                filesSection,
                "",
                "Inferred feature tags:",
                areaSection,
              ].join("\n");

              core.setOutput("context", contextBlock);
            } catch (error) {
              core.warning(`Failed to collect compare context: ${error}`);
              core.setOutput("context", `Base tag: ${base}\nTarget tag: ${tag}\n- Comparison lookup failed.`);
            }

      - name: Generate user-friendly notes with GitHub Models
        id: user_notes
        uses: actions/ai-inference@v1
        continue-on-error: true
        with:
          model: openai/gpt-4o-mini
          prompt: |
            You are writing user-facing release notes for DropPilot (a Twitch Drops automation desktop app).
            Audience: non-technical end users.

            Output rules:
            - Return only markdown bullet points (3 to 6 bullets).
            - Use plain, concrete language focused on user-visible changes.
            - Do not mention file paths, commits, pull requests, CI, refactoring, or architecture.
            - Do not invent behavior that is not supported by the provided context.
            - Every bullet must be directly supported by the changelog/context below; if not, omit it.
            - Prefer outcomes ("Auto-watch now picks ...") over implementation details.
            - Use changed files only to infer user-facing feature areas; never show file names in output.
            - Inferred feature tags are hints only and are not sufficient evidence for a bullet on their own.
            - Do not use hype or guarantees (forbidden examples: "never miss", "always", "ensuring", "guaranteed").
            - Do not mention "streaming sessions" unless that phrase is explicitly present in the inputs.
            - Do not claim performance/stability improvements unless explicitly evidenced in the inputs.
            - If evidence is mostly technical/internal, return exactly this single bullet:
            - Internal maintenance and stability improvements.

            Release metadata:
            - Version tag: ${{ steps.generated_notes.outputs.tag }}
            - Pre-release: ${{ steps.generated_notes.outputs.is_prerelease }}

            Technical changelog (GitHub-generated):
            ${{ steps.generated_notes.outputs.notes }}

            Additional context from git comparison:
            ${{ steps.release_context.outputs.context }}

      - name: Build release body
        run: |
          cat <<'EOF' > release_body.md
          ## What's new for users

          ${{ steps.user_notes.outputs.response || '- No major user-facing changes in this release.' }}

          ## Full changelog

          ${{ steps.generated_notes.outputs.notes || format('Compared against {0}. No detailed changelog entries were generated for this tag range.', steps.generated_notes.outputs.base_tag || 'the previous release') }}
          EOF

      - name: Resolve release visibility
        id: release_visibility
        run: |
          TAG="${GITHUB_REF_NAME}"
          if [[ "$TAG" == *"-test"* ]]; then
            echo "draft=true" >> "$GITHUB_OUTPUT"
            echo "prerelease=true" >> "$GITHUB_OUTPUT"
          elif [[ "$TAG" == *"-rc"* || "$TAG" == *"-beta"* || "$TAG" == *"-alpha"* ]]; then
            echo "draft=false" >> "$GITHUB_OUTPUT"
            echo "prerelease=true" >> "$GITHUB_OUTPUT"
          else
            echo "draft=false" >> "$GITHUB_OUTPUT"
            echo "prerelease=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Publish GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          body_path: release_body.md
          draft: ${{ steps.release_visibility.outputs.draft }}
          prerelease: ${{ steps.release_visibility.outputs.prerelease }}
          files: |
            artifacts/*.exe
            artifacts/*.blockmap
            artifacts/*.dmg
            artifacts/*.zip
            artifacts/*.yml
